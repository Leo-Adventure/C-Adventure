# 右值引用
左值：表达式结束后依然存在的持久对象
右值：表达式结束后就不存在的临时对象
区分的便捷办法：看能不能对表达式取地址

推断类型：绑定的类型未知，有可能是左值也可能是右值
T&& 当发生自动类型推断（）如函数模板的类型自动推导的时候，是一个推断类型，且推断类型仅仅在 T&& 下发生，任何一点附加条件都会使之失效，比如加上 const 之后便会变成普通的 右值引用

编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值

## 总结
- 左值和右值是独立于它们的类型的，右值引用类型也可能是左值也可能是右值
- auto && 或者函数参数类型自动推导的 T&& 是一个未定的引用类型，被称为 unibersal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型
- 所有的右值引用叠加到右值引用上依然是一个右值引用，其他引用折叠都为左值引用。当T&&为模板参数时，输入左值，它会变成左值引用，而输入右值时则变为具名的右值引用
- 编译器会将已经命名的右值引用视为左值，将未命名的右值引用视为右值

## 移动构造
参数是一个右值引用类型的参数 A&&，可以避免对临时对象的深拷贝，提高性能

```cpp
A(A && a):m_ptr(a.m_ptr){
        a.m_ptr = nullptr;
        cout << "move construct" << endl;
    }
```
这里的 A&& 会根据参数是左值还是右值来建立分支，如果是临时值，就会选择移动构造函数。

## 移动构造函数和移动赋值函数
有了右值引用和移动语义，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。
需要注意的是，我们在提供右值引用的构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成功还可以使用拷贝构造，使得代码更加安全

