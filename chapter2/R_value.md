# 右值引用
左值：表达式结束后依然存在的持久对象
右值：表达式结束后就不存在的临时对象
区分的便捷办法：看能不能对表达式取地址

推断类型：绑定的类型未知，有可能是左值也可能是右值
T&& 当发生自动类型推断（）如函数模板的类型自动推导的时候，是一个推断类型，且推断类型仅仅在 T&& 下发生，任何一点附加条件都会使之失效，比如加上 const 之后便会变成普通的 右值引用

编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值

## 总结
- 左值和右值是独立于它们的类型的，右值引用类型也可能是左值也可能是右值
- auto && 或者函数参数类型自动推导的 T&& 是一个未定的引用类型，被称为 unibersal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型
- 所有的右值引用叠加到右值引用上依然是一个右值引用，其他引用折叠都为左值引用。当T&&为模板参数时，输入左值，它会变成左值引用，而输入右值时则变为具名的右值引用
- 编译器会将已经命名的右值引用视为左值，将未命名的右值引用视为右值

## 移动构造
参数是一个右值引用类型的参数 A&&，可以避免对临时对象的深拷贝，提高性能

```cpp
A(A && a):m_ptr(a.m_ptr){
        a.m_ptr = nullptr;
        cout << "move construct" << endl;
    }
```
这里的 A&& 会根据参数是左值还是右值来建立分支，如果是临时值，就会选择移动构造函数。

## 移动构造函数和移动赋值函数
有了右值引用和移动语义，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。
需要注意的是，我们在提供右值引用的构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成功还可以使用拷贝构造，使得代码更加安全

## Move 语义
move 实际上不能移动任何东西，唯一的功能就是将一个左值强制转换成一个右值引用，使得可以通过右值引用使用该值，以用于移动语义。强制转换为右值是为了方便实现移动构造

在 C++11 之前的拷贝构造函数以及赋值函数都需要销毁现有对象指向的资源，并且复制 被复制对象所指向的资源，并且将原有的指针指向这块资源
更加有效率的方法是直接交换两者的资源指针，然后让临时对象的析构函数去销毁原有的资源

## forward 和 完美转发
完美转发：是指在函数模板当中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。

## emplace_back 减少内存拷贝和移动

## 总结
1. 右值引用仅仅是通过改变资源的所有者来避免内存的拷贝，能大幅度提高性能
2. forward 能根据参数的实际类型转发给正确的函数
3. emplace 系列函数通过直接构造对象的方式避免了内存的拷贝和移动
4. 无序容器在插入元素时不排序，提高了插入效率，不过对于自定义key是需要提供 hash 函数和比较函数
